<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Movies</title>
<style>
body{margin:0;font-family:Arial,sans-serif;background:#141414;color:#fff}
header{background:#141414;padding:15px;display:flex;justify-content:space-between;align-items:center;position:sticky;top:0;z-index:10}
header h1{color:#e50914;margin:0;font-size:18px}
.search-container{position:relative;display:inline-block}
input[type="text"]{padding:6px;font-size:14px;width:150px;border-radius:4px;border:none}
.dropdown{position:absolute;top:100%;left:0;right:0;background:#333;border:1px solid #555;max-height:200px;overflow-y:auto;z-index:1000;display:none}
.dropdown-item{padding:8px;cursor:pointer;border-bottom:1px solid #444;display:flex;align-items:center}
.dropdown-item:hover{background:#555}
.dropdown-item.selected{background:#e50914;color:#fff}
.dropdown-item mark{background:#ff6b35;color:#fff;padding:1px 2px;border-radius:2px}
.dropdown-item img{width:50px;height:75px;object-fit:cover;margin-right:10px;border-radius:4px}
section{margin-top:15px}
h2{margin-left:10px;font-size:16px}
.carousel-wrapper{position:relative}
.carousel{display:flex;overflow-x:auto;gap:8px;padding:15px;scroll-behavior:smooth;cursor:grab}
.carousel::-webkit-scrollbar{display:none}
.movie-card{min-width:120px;cursor:pointer;position:relative;transition:transform .2s;flex-shrink:0}
.movie-card img{width:100%;border-radius:6px;display:block}
.movie-title{position:absolute;bottom:3px;left:3px;right:3px;background:rgba(0,0,0,.7);padding:1px 3px;font-size:12px;border-radius:4px;text-align:center}
.preview-card{display:none!important}
.arrow{display:none} /* hide arrows on mobile */

/* Video Provider Modal Styles */
.video-modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.9);
}

.video-modal-content {
  background-color: #1a1a1a;
  margin: 10% auto;
  padding: 20px;
  border: 1px solid #333;
  border-radius: 8px;
  width: 80%;
  max-width: 600px;
  color: white;
}

.video-modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.video-modal-header h3 {
  margin: 0;
  color: #e50914;
}

.close-modal {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.close-modal:hover {
  color: white;
}

.provider-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin-bottom: 20px;
  max-height: 400px;
  overflow-y: auto;
}

.provider-btn {
  background: #333;
  border: 1px solid #555;
  color: white;
  padding: 15px;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-align: center;
}

.provider-btn:hover {
  background: #e50914;
  border-color: #e50914;
}

.provider-btn.selected {
  background: #e50914;
  border-color: #e50914;
}

.video-container {
  width: 100%;
  height: 400px;
  border: 1px solid #333;
  border-radius: 6px;
  overflow: hidden;
  display: none;
}

.video-iframe {
  width: 100%;
  height: 100%;
  border: none;
}
</style>
<script>
const WORKER_URL = 'https://noisy-frog-a9ab.22afed28-f0b2-46d0-8804-c90e25c90bd4.workers.dev';
</script>
</head>
<body>
<header>
  <h1>Movies</h1>
  <div class="search-container">
    <input type="text" id="search" placeholder="Search...">
  </div>
</header>

<section>
</section>

<section id="mostPopularMovies" style="margin: 20px;">
  <h2 style="color: white; margin-left: 10px;">Most Popular Movies</h2>
  <div id="popularMoviesGrid" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;"></div>
</section>

<script>
async function fetchCSV(url) {
  const response = await fetch(url);
  const text = await response.text();
  return text;
}

function parseCSV(csvText) {
  // Parse CSV with support for quoted fields containing commas
  const lines = csvText.trim().split('\n');
  const headers = parseCSVLine(lines[0]);
  const rows = lines.slice(1);
  return rows.map(line => {
    const values = parseCSVLine(line);
    const obj = {};
    headers.forEach((header, i) => {
      obj[header.trim()] = values[i] ? values[i].trim() : '';
    });
    return obj;
  });
}

function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"' && (i === 0 || line[i - 1] !== '\\')) {
      inQuotes = !inQuotes;
      continue;
    }
    if (char === ',' && !inQuotes) {
      result.push(current);
      current = '';
      continue;
    }
    current += char;
  }
  result.push(current);
  return result;
}

function createMovieCard(movie) {
  console.log('Parsed movie object:', movie);
  const card = document.createElement('div');
  card.style.width = '150px';
  card.style.position = 'relative';
  card.style.cursor = 'pointer';

  const posterUrl = movie.Poster || movie.Image || '';
  const imdbId = movie['IMDb URL'] ? (movie['IMDb URL'].match(/tt\d{7,8}/) || [''])[0] : '';

  const img = document.createElement('img');
  console.log('Setting poster URL for movie:', movie['Movie Title'], posterUrl);
  img.src = posterUrl && posterUrl !== "N/A" ? posterUrl : 'https://image.tmdb.org/t/p/w500/qmDpIHrmpJINaRKAfWQfftjCdyi.jpg';
  img.alt = movie['Movie Title'] || 'Movie Poster';
  img.style.width = '100%';
  img.style.borderRadius = '6px';
  img.style.display = 'block';
  img.loading = 'lazy';
  img.onerror = () => {
    img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUwIiBoZWlnaHQ9IjIyNSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTUwIiBoZWlnaHQ9IjIyNSIgZmlsbD0iIzAwMCIvPjx0ZXh0IHg9Ijc1IiB5PSIxMTIiIGZpbGw9IiNGRkYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiPk5vIEltYWdlPC90ZXh0Pjwvc3ZnPg==';
  };

  card.appendChild(img);

  const titleDiv = document.createElement('div');
  titleDiv.textContent = movie['Movie Title'] || '';
  titleDiv.style.position = 'absolute';
  titleDiv.style.bottom = '5px';
  titleDiv.style.left = '5px';
  titleDiv.style.right = '5px';
  titleDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
  titleDiv.style.color = 'white';
  titleDiv.style.fontSize = '12px';
  titleDiv.style.padding = '2px 4px';
  titleDiv.style.borderRadius = '4px';
  titleDiv.style.textAlign = 'center';

  card.appendChild(titleDiv);

  // Add click handler to open video provider modal
  card.onclick = () => {
    showVideoModal(movie['Movie Title'] || '', imdbId, 'movie');
  };

  return card;
}

async function fetchPoster(imdbID) {
  // Ensure imdbID is in correct format: tt followed by 7 or 8 digits
  const validImdbIdMatch = imdbID.match(/^tt\d{7,8}$/);
  if (!validImdbIdMatch) {
    console.warn('Invalid IMDb ID format:', imdbID);
    return '';
  }
  const validImdbID = validImdbIdMatch[0];

  try {
    // Try TMDB API first for poster
    console.log('Trying TMDB API for poster for IMDb ID:', validImdbID);

    try {
      const apiKeyResponse = await fetch('/api/tmdb-key');
      const tmdbApiKey = await apiKeyResponse.text();
      const tmdbUrl = `https://api.themoviedb.org/3/find/${validImdbID}?api_key=${tmdbApiKey}&external_source=imdb_id`;

      const tmdbResponse = await fetch(tmdbUrl);
      if (tmdbResponse.ok) {
        const tmdbData = await tmdbResponse.json();
        if (tmdbData.movie_results && tmdbData.movie_results.length > 0) {
          const movie = tmdbData.movie_results[0];
          if (movie.poster_path) {
            const posterUrl = `https://image.tmdb.org/t/p/w500${movie.poster_path}`;
            console.log('TMDB poster found:', posterUrl);
            return posterUrl;
          }
        }
      }
    } catch (error) {
      console.error('TMDB fetch failed for', validImdbID, error);
    }

    // If TMDB fails, try the original worker API as fallback
    console.log('Trying worker API as fallback for IMDb ID:', validImdbID);
    const apiUrl = `https://noisy-frog-a9ab.22afed28-f0b2-46d0-8804-c90e25c90bd4.workers.dev?movie=${validImdbID}`;
    const response = await fetch(apiUrl);

    if (response.ok) {
      const text = await response.text();
      console.log('Raw API response text for', validImdbID, text);
      let data;
      try {
        data = JSON.parse(text);
      } catch (parseError) {
        console.error('Failed to parse JSON for', validImdbID, parseError);
        throw new Error('JSON parse failed');
      }

      if (data && data.Poster && data.Poster !== "N/A") {
        console.log('Worker poster found:', data.Poster);
        return data.Poster;
      }
    }

    console.warn('No poster found for', validImdbID);
    return '';
  } catch (error) {
    console.error('Error in fetchPoster for', imdbID, error);
    return '';
  }
}

async function renderMostPopularMovies() {
  const csvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSy8FBC-tlZoaaP1mVzAgxTy-817j3ViS_h9dM8rz0VOEkUqVj77vGVrjNneAYQbkP9R48dGMnGIPX4/pub?gid=0&single=true&output=csv';
  try {
    console.log('Fetching CSV from:', csvUrl);
    const csvText = await fetchCSV(csvUrl);
    console.log('CSV text received:', csvText);
    const movies = parseCSV(csvText);
    console.log('Parsed movies:', movies);
    const grid = document.getElementById('popularMoviesGrid');
    if (!grid) {
      console.error('Grid element not found');
      return;
    }
    for (const movie of movies) {
      console.log('Processing movie:', movie);
      // Extract IMDb ID from IMDb URL
      let imdbID = '';
      if (movie['IMDb URL']) {
        // Fix regex to correctly extract IMDb ID (tt followed by 7 or 8 digits)
        const match = movie['IMDb URL'].match(/tt\d{7,8}/);
        if (match) imdbID = match[0];
      }
      if (imdbID) {
        console.log('Fetching poster for:', imdbID);
        movie.Poster = await fetchPoster(imdbID);
      } else {
        movie.Poster = '';
      }
      const card = createMovieCard(movie);
      grid.appendChild(card);
    }
    console.log('Movies rendered successfully');
  } catch (error) {
    console.error('Failed to load popular movies:', error);
    // Add a fallback message
    const grid = document.getElementById('popularMoviesGrid');
    if (grid) {
      grid.innerHTML = '<p style="color: red;">Failed to load movies. Check console for errors.</p>';
    }
  }
}

document.addEventListener('DOMContentLoaded', () => {
  renderMostPopularMovies();
});
</script>

<script>
// Enhanced search functionality with debouncing, caching, and keyboard navigation
class SearchManager {
  constructor() {
    this.searchInput = document.getElementById('search');
    this.dropdown = null;
    this.debounceTimer = null;
    this.cache = new Map();
    this.selectedIndex = -1;
    this.searchResults = [];
    this.isLoading = false;

    this.init();
  }

  init() {
    this.createDropdown();
    this.bindEvents();
  }

  createDropdown() {
    if (this.dropdown) return;

    this.dropdown = document.createElement('div');
    this.dropdown.className = 'dropdown';
    this.dropdown.setAttribute('role', 'listbox');
    this.dropdown.setAttribute('aria-label', 'Search results');
    this.dropdown.style.display = 'none';

    const searchContainer = document.querySelector('.search-container');
    searchContainer.appendChild(this.dropdown);
  }

  bindEvents() {
    // Debounced input handler
    this.searchInput.addEventListener('input', (e) => {
      this.handleInput(e.target.value);
    });

    // Keyboard navigation
    this.searchInput.addEventListener('keydown', (e) => {
      this.handleKeydown(e);
    });

    // Focus/blur handlers
    this.searchInput.addEventListener('focus', () => {
      if (this.searchResults.length > 0) {
        this.showDropdown();
      }
    });

    this.searchInput.addEventListener('blur', () => {
      // Delay hiding to allow dropdown clicks
      setTimeout(() => {
        if (!this.dropdown.contains(document.activeElement)) {
          this.hideDropdown();
        }
      }, 150);
    });

    // Dropdown click handler
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('dropdown-item')) {
        this.handleDropdownItemClick(e.target);
      } else if (!document.querySelector('.search-container').contains(e.target)) {
        this.hideDropdown();
      }
    });
  }

  handleInput(value) {
    const query = value.trim();

    // Clear previous timer
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    // Hide dropdown for short queries or empty input
    if (!query || query.length < 2) {
      this.hideDropdown();
      this.isLoading = false;
      return;
    }

    // Show loading state
    this.showLoadingState();

    // Debounce search requests
    this.debounceTimer = setTimeout(() => {
      this.performSearch(query);
    }, 300);
  }

  async performSearch(query) {
    // Check cache first
    if (this.cache.has(query)) {
      this.displayResults(this.cache.get(query));
      return;
    }

    this.isLoading = true;

    try {
      console.log('Searching for:', query);

      // Step 1: Try TMDB API first (more reliable for finding titles)
      const tmdbResults = await this.searchTMDB(query);

      if (tmdbResults.length > 0) {
        // Step 2: For each TMDB result, get detailed info from OMDB/IMDb API
        const detailedResults = await this.getDetailedMovieInfo(tmdbResults);
        this.cache.set(query, detailedResults);
        this.displayResults(detailedResults);
      } else {
        // Step 3: Try the original worker API as fallback
        const workerResults = await this.searchWorkerAPI(query);
        if (workerResults.length > 0) {
          this.cache.set(query, workerResults);
          this.displayResults(workerResults);
        } else {
          this.showNoResults();
        }
      }
    } catch (error) {
      console.error('Search error:', error);
      this.showErrorState(`Search failed: ${error.message}`);
    } finally {
      this.isLoading = false;
    }
  }

  async searchTMDB(query) {
    try {
      const apiKeyResponse = await fetch('/api/tmdb-key');
      const tmdbApiKey = await apiKeyResponse.text();
      const tmdbUrl = `https://api.themoviedb.org/3/search/movie?api_key=${tmdbApiKey}&query=${encodeURIComponent(query)}&language=en-US&page=1`;

      const response = await fetch(tmdbUrl);
      if (!response.ok) {
        throw new Error(`TMDB API error: ${response.status}`);
      }

      const data = await response.json();
      console.log('TMDB search results:', data);

      if (data.results && data.results.length > 0) {
        return data.results.slice(0, 5).map(movie => ({
          Title: movie.title,
          Year: movie.release_date ? movie.release_date.substring(0, 4) : '',
          imdbID: movie.id.toString(),
          Type: 'movie',
          Poster: movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : '',
          tmdbData: movie // Store full TMDB data for later use
        }));
      }
      return [];
    } catch (error) {
      console.error('TMDB search failed:', error);
      return [];
    }
  }

  async getDetailedMovieInfo(tmdbResults) {
    const detailedResults = [];

    for (const movie of tmdbResults) {
      try {
        // Try to get detailed info from the worker API using the movie title
        const workerResponse = await fetch(`${WORKER_URL}?movie=${encodeURIComponent(movie.Title)}`);

        if (workerResponse.ok) {
          const workerData = await workerResponse.json();
          console.log('Worker API detailed data:', workerData);

          if (workerData.Response === "True") {
            // Use the detailed data from worker API
            detailedResults.push({
              Title: workerData.Title,
              Year: workerData.Year,
              imdbID: workerData.imdbID,
              Type: workerData.Type,
              Poster: workerData.Poster !== "N/A" ? workerData.Poster : movie.Poster,
              Plot: workerData.Plot,
              Genre: workerData.Genre,
              Director: workerData.Director,
              Actors: workerData.Actors
            });
          } else {
            // Fallback to TMDB data
            detailedResults.push(movie);
          }
        } else {
          // Use TMDB data as fallback
          detailedResults.push(movie);
        }
      } catch (error) {
        console.error('Failed to get detailed info for:', movie.Title, error);
        detailedResults.push(movie);
      }
    }

    return detailedResults;
  }

  async searchWorkerAPI(query) {
    try {
      const response = await fetch(`${WORKER_URL}?movie=${encodeURIComponent(query)}`);

      if (!response.ok) {
        throw new Error(`Worker API error: ${response.status}`);
      }

      const responseText = await response.text();
      console.log('Worker API raw response:', responseText);

      let data;
      try {
        data = JSON.parse(responseText);
      } catch (parseError) {
        console.error('Failed to parse Worker API JSON:', parseError);
        return [];
      }

      console.log('Worker API parsed response:', data);

      // Handle different response formats
      if (data.Search && Array.isArray(data.Search)) {
        return data.Search.slice(0, 5);
      } else if (data.Response === "True" && data.Title) {
        return [data];
      }

      return [];
    } catch (error) {
      console.error('Worker API search failed:', error);
      return [];
    }
  }

  async performFallbackSearch(query) {
    try {
      console.log('Attempting fallback search for:', query);

      // Use TMDB API as fallback
      const apiKeyResponse = await fetch('/api/tmdb-key');
      const tmdbApiKey = await apiKeyResponse.text();
      const tmdbUrl = `https://api.themoviedb.org/3/search/movie?api_key=${tmdbApiKey}&query=${encodeURIComponent(query)}&language=en-US&page=1`;

      const response = await fetch(tmdbUrl);
      if (!response.ok) {
        throw new Error(`TMDB API error: ${response.status}`);
      }

      const data = await response.json();
      console.log('TMDB fallback response:', data);

      if (data.results && data.results.length > 0) {
        // Convert TMDB results to expected format
        const results = data.results.slice(0, 5).map(movie => ({
          Title: movie.title,
          Year: movie.release_date ? movie.release_date.substring(0, 4) : '',
          imdbID: movie.id.toString(),
          Type: 'movie',
          Poster: movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : ''
        }));

        // Cache the results
        this.cache.set(query, results);
        this.displayResults(results);
      } else {
        this.showNoResults();
      }
    } catch (fallbackError) {
      console.error('Fallback search failed:', fallbackError);
      this.showErrorState('Search failed. Please check your connection and try again.');
    }
  }

  displayResults(results) {
    this.searchResults = results.slice(0, 5); // Limit to 5 results
    this.selectedIndex = -1;

    if (this.searchResults.length === 0) {
      this.showNoResults();
      return;
    }

    this.dropdown.innerHTML = this.searchResults.map((result, index) =>
      `<div class="dropdown-item" data-imdb="${result.imdbID}" data-type="${result.Type}" data-index="${index}" role="option" aria-selected="false">
        <img src="${result.Poster || 'https://image.tmdb.org/t/p/w500/qmDpIHrmpJINaRKAfWQfftjCdyi.jpg'}" alt="${result.Title}" onerror="this.onerror=null;this.src='https://image.tmdb.org/t/p/w500/qmDpIHrmpJINaRKAfWQfftjCdyi.jpg';">
        <div>
          <strong>${this.highlightQuery(result.Title)}</strong> (${result.Year}) - ${result.Type}
        </div>
      </div>`
    ).join('');

    this.showDropdown();
  }

  highlightQuery(text) {
    const query = this.searchInput.value.trim();
    if (!query || query.length < 2) return text;

    const regex = new RegExp(`(${query})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }

  showLoadingState() {
    this.dropdown.innerHTML = '<div class="dropdown-item" style="text-align: center; color: #999;">Searching...</div>';
    this.dropdown.style.display = 'block';
  }

  showErrorState(message) {
    this.dropdown.innerHTML = `<div class="dropdown-item" style="text-align: center; color: #e50914;">${message}</div>`;
    this.dropdown.style.display = 'block';
  }

  showNoResults() {
    const query = this.searchInput.value.trim();
    this.dropdown.innerHTML = `<div class="dropdown-item" style="text-align: center; color: #999;">No results for "${query}"</div>`;
    this.dropdown.style.display = 'block';
  }

  showDropdown() {
    this.dropdown.style.display = 'block';
    this.searchInput.setAttribute('aria-expanded', 'true');
  }

  hideDropdown() {
    this.dropdown.style.display = 'none';
    this.searchInput.setAttribute('aria-expanded', 'false');
    this.selectedIndex = -1;
  }

  handleKeydown(e) {
    if (this.searchResults.length === 0) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        this.selectedIndex = Math.min(this.selectedIndex + 1, this.searchResults.length - 1);
        this.updateSelection();
        break;

      case 'ArrowUp':
        e.preventDefault();
        this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
        this.updateSelection();
        break;

      case 'Enter':
        e.preventDefault();
        if (this.selectedIndex >= 0) {
          const selectedItem = this.dropdown.querySelector(`[data-index="${this.selectedIndex}"]`);
          this.handleDropdownItemClick(selectedItem);
        } else {
          // Perform search with current input
          this.handleEnterKey();
        }
        break;

      case 'Escape':
        e.preventDefault();
        this.hideDropdown();
        this.searchInput.blur();
        break;
    }
  }

  updateSelection() {
    const items = this.dropdown.querySelectorAll('.dropdown-item');

    items.forEach((item, index) => {
      if (index === this.selectedIndex) {
        item.classList.add('selected');
        item.setAttribute('aria-selected', 'true');
        item.scrollIntoView({ block: 'nearest' });
      } else {
        item.classList.remove('selected');
        item.setAttribute('aria-selected', 'false');
      }
    });
  }

  handleDropdownItemClick(item) {
    const imdb = item.dataset.imdb;
    const type = item.dataset.type;
    const title = item.textContent.split(' (')[0].replace(/<[^>]*>/g, ''); // Extract title and remove HTML tags

    // Show provider selection modal directly
    showVideoModal(title, imdb, type);

    this.hideDropdown();
    this.searchInput.value = '';
  }

  async handleEnterKey() {
    const query = this.searchInput.value.trim();
    if (!query) return;

    try {
      const response = await fetch(`${WORKER_URL}?movie=${encodeURIComponent(query)}`);
      const data = await response.json();

      if (data.Search && data.Search.length > 0) {
        const first = data.Search[0];
        const type = first.Type === "series" ? "series" : "movie";
        const title = first.Title;

        // Show provider selection instead of opening directly
        showVideoModal(title, first.imdbID, type);

        // Clear search input
        this.searchInput.value = '';
        this.hideDropdown();
      } else {
        this.showErrorState("Movie not found!");
      }
    } catch (error) {
      console.error('Enter key search error:', error);
      this.showErrorState("Search failed. Please try again.");
    }
  }

  // Cleanup method
  destroy() {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    if (this.dropdown && this.dropdown.parentNode) {
      this.dropdown.parentNode.removeChild(this.dropdown);
    }
  }
}

// Initialize search manager when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  window.searchManager = new SearchManager();
});
</script>

<!-- Video Provider Modal -->
<div id="videoModal" class="video-modal">
  <div class="video-modal-content">
    <div class="video-modal-header">
      <h3 id="modalTitle">Select Video Provider</h3>
      <span class="close-modal" id="closeModal">&times;</span>
    </div>
    <div id="providerGrid" class="provider-grid">
      <!-- Provider buttons will be added here by JavaScript -->
    </div>
    <div id="videoContainer" class="video-container">
      <iframe id="videoIframe" class="video-iframe" src="" allowfullscreen></iframe>
    </div>
  </div>
</div>

<script defer>
// fetch movies in parallel
async function fetchMovies(titles){
  try{
    console.log('Fetching movies for titles:', titles);
    const results=await Promise.all(titles.map(title=>
      fetch(`${WORKER_URL}?movie=${encodeURIComponent(title)}`).then(r=>r.json())
    ));
    console.log('Fetched results:', results);
    const filtered = results.filter(m=>m.Response==="True").map(m=>({
      title:m.Title,imdb:m.imdbID,poster:m.Poster,plot:m.Plot, year: m.Year
    }));
    console.log('Filtered movies:', filtered);
    return filtered;
  }catch(e){console.error(e);return []}
}

// render carousel for mobile
function renderCarousel(movies,containerId, type = "movie"){
  console.log('Rendering movies for', containerId, ':', movies);
  const container=document.getElementById(containerId);
  container.innerHTML=movies.map(movie=>`
    <div class="movie-card" data-imdb="${movie.imdb}">
      <img src="${movie.poster}" alt="${movie.title}" loading="lazy">
      <div class="movie-title">${movie.title}</div>
    </div>
  `).join("");

  container.querySelectorAll(".movie-card").forEach(card=>{
    card.onclick=async ()=>{
      try {
        const imdb = card.dataset.imdb;
        const title = card.querySelector('.movie-title').textContent;

        // Show provider selection modal instead of opening directly
        showVideoModal(title, imdb, type);
      } catch (err) {
        console.error(err);
        alert("Failed to load video options");
      }
    };
  });
}

// enable swipe
function addSwipe(id){
  const slider=document.getElementById(id);
  let isDown=false,startX,scrollLeft;
  slider.addEventListener("pointerdown",e=>{isDown=true;startX=e.pageX-slider.offsetLeft;scrollLeft=slider.scrollLeft});
  slider.addEventListener("pointerleave",()=>isDown=false);
  slider.addEventListener("pointerup",()=>isDown=false);
  slider.addEventListener("pointermove",e=>{
    if(!isDown)return;
    e.preventDefault();
    slider.scrollLeft=scrollLeft-(e.pageX-startX)*2;
  });
}

// Show video provider modal
function showVideoModal(title, imdbId, type) {
  console.log('showVideoModal called with:', title, imdbId, type);
  const modal = document.getElementById('videoModal');
  const modalTitle = document.getElementById('modalTitle');
  const providerGrid = document.getElementById('providerGrid');
  const videoContainer = document.getElementById('videoContainer');
  const videoIframe = document.getElementById('videoIframe');

  if (!modal || !modalTitle || !providerGrid) {
    console.error('Modal elements not found');
    return;
  }

  // Set modal title
  modalTitle.textContent = `Select ${type === 'series' ? 'Episode' : 'Video'} Provider for ${title}`;
  modalTitle.dataset.imdb = imdbId;
  modalTitle.dataset.type = type;

  // Clear previous content
  providerGrid.innerHTML = '';
  videoContainer.style.display = 'none';
  videoIframe.src = '';

  // Add season and episode inputs for TV series
  if (type === 'series') {
    const seasonEpisodeDiv = document.createElement('div');
    seasonEpisodeDiv.innerHTML = `
      <label for="seasonInput">Season:</label>
      <input type="number" id="seasonInput" min="1" value="1" style="margin: 0 10px;">
      <label for="episodeInput">Episode:</label>
      <input type="number" id="episodeInput" min="1" value="1" style="margin: 0 10px;">
    `;
    providerGrid.appendChild(seasonEpisodeDiv);
  }

  // Add provider buttons with debugging and error handling
  console.log('videoProviders array:', videoProviders);
  videoProviders.forEach(provider => {
    try {
      console.log('Creating button for provider:', provider.name);
      const button = document.createElement('button');
      button.className = 'provider-btn';
      button.textContent = provider.name;
      button.dataset.provider = provider.domain;
      button.onclick = () => {
        const season = type === 'series' ? document.getElementById('seasonInput').value : 1;
        const episode = type === 'series' ? document.getElementById('episodeInput').value : 1;
        selectProvider(provider.domain, imdbId, type, title, season, episode);
      };
      providerGrid.appendChild(button);
      console.log('Button added for:', provider.name);
    } catch (error) {
      console.error('Error creating button for provider:', provider.name, error);
    }
  });
  console.log('Provider buttons added');

  // Show modal
  modal.style.display = 'block';
  console.log('Modal displayed');
}

// Select video provider and load video
function selectProvider(provider, imdbId, type, title, season = 1, episode = 1) {
  const embedUrl = generateEmbedUrl(provider, imdbId, type, season, episode);

  if (embedUrl) {
    // Close the modal
    closeVideoModal();

    // Open video in new tab
    window.open(embedUrl, '_blank');

    console.log(`Opened ${title} on ${provider}: ${embedUrl}`);
  } else {
    alert(`Unable to generate embed URL for ${provider}`);
  }
}

// Close modal
function closeVideoModal() {
  const modal = document.getElementById('videoModal');
  const videoIframe = document.getElementById('videoIframe');

  modal.style.display = 'none';
  videoIframe.src = '';
  document.getElementById('providerGrid').style.display = 'grid';
  document.getElementById('modalTitle').textContent = 'Select Video Provider';
}

// Modal event listeners
document.getElementById('closeModal').onclick = closeVideoModal;

// Close modal when clicking outside
document.getElementById('videoModal').onclick = function(e) {
  if (e.target === this) {
    closeVideoModal();
  }
};

// Close modal on Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    closeVideoModal();
  }
});

// handle dropdown clicks
document.addEventListener('click', async function(e){
  const dropdown = document.querySelector('.dropdown');
  if (e.target.classList.contains('dropdown-item')) {
    const imdb = e.target.dataset.imdb;
    const type = e.target.dataset.type;
    const title = e.target.textContent.split(' (')[0]; // Extract title from dropdown text

    // Show provider selection instead of opening directly
    showVideoModal(title, imdb, type);

    if (dropdown) dropdown.style.display = 'none';
    document.getElementById('search').value = '';
  } else if (dropdown && !document.querySelector('.search-container').contains(e.target)) {
    dropdown.style.display = 'none';
  }
});

// Video provider configuration
const videoProviders = [
  { name: 'AutoEmbed.cc', domain: 'autoembed.cc' },
  { name: 'Embed.su', domain: 'embed.su' },
  { name: '111Movies.com', domain: '111movies.com' },
  { name: 'VidLink.pro', domain: 'vidlink.pro' },
  { name: 'Player.Videasy.net', domain: 'player.videasy.net' },
  { name: 'VidSrc.to', domain: 'vidsrc.to' },
  { name: 'VidSrc.cc', domain: 'vidsrc.cc' },
  { name: 'VidRock.net', domain: 'vidrock.net' },
  { name: 'VidSrc.me', domain: 'vidsrc.me' },
  { name: 'VidFast.pro', domain: 'vidfast.pro' }
];

  // Generate embed URL for a provider
  function generateEmbedUrl(provider, imdbId, type, season = 1, episode = 1) {
    const baseUrls = {
      'vidsrc.cc': type === 'series'
        ? `https://vidsrc.cc/v2/embed/tv/${imdbId}/${season}?ads=0&disable_ads=1`
        : `https://vidsrc.cc/v2/embed/movie/${imdbId}?ads=0&disable_ads=1`,
      'vidrock.net': type === 'series'
        ? `https://vidrock.net/tv/${imdbId}/${season}/${episode}?ads=0&disable_ads=1`
        : `https://vidrock.net/movie/${imdbId}?ads=0&disable_ads=1`,
      'vidsrc.me': `https://vidsrc.me/embed/${type}/${imdbId}?ads=0&disable_ads=1`,
      'vidfast.pro': type === 'series'
        ? `https://vidfast.pro/tv/${imdbId}/${season}/${episode}?autoPlay=true&ads=0&disable_ads=1`
        : `https://vidfast.pro/movie/${imdbId}?autoPlay=true&ads=0&disable_ads=1`,
      'autoembed.cc': type === 'series'
        ? `https://player.autoembed.cc/embed/tv/${imdbId}/${season}/${episode}`
        : `https://player.autoembed.cc/embed/movie/${imdbId}`,
      'embed.su': type === 'series'
        ? `https://embed.su/embed/tv/${imdbId}/${season}/${episode}`
        : `https://embed.su/embed/movie/${imdbId}`,
      '111movies.com': type === 'series'
        ? `https://111movies.com/tv/${imdbId}/${season}/${episode}`
        : `https://111movies.com/movie/${imdbId}`,
      'vidlink.pro': type === 'series'
        ? `https://vidlink.pro/tv/${imdbId}/${season}/${episode}`
        : type === 'anime'
        ? `https://vidlink.pro/anime/${imdbId}/${episode}/sub?fallback=true`
        : `https://vidlink.pro/movie/${imdbId}`,
      'player.videasy.net': type === 'series'
        ? `https://player.videasy.net/tv/${imdbId}/${season}/${episode}`
        : type === 'anime'
        ? `https://player.videasy.net/anime/${imdbId}/${episode}?dub=false`
        : `https://player.videasy.net/movie/${imdbId}`,
      'vidsrc.to': type === 'series'
        ? `https://vidsrc.to/embed/tv/${imdbId}/${season}/${episode}`
        : `https://vidsrc.to/embed/movie/${imdbId}`
    };

  return baseUrls[provider] || '';
}
</script>
</body>
</html>










